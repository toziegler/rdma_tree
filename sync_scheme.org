* Synchronization Scheme

** Previous implementation
- pseudo code does not quite tell the full story but should generally work
- Blink tree makes prefetching logic and traversal more complex 
- tree is anyway optimized for lookups scans
- try to implement simple b-tree in python from pseudo-code just to prove 


* New Implementation B+ Tree


** Abstractions

*** Tree
Split tree into 2 parts inner and leaf this allows us to swap the access methods

** One-sided lookup
Instead of validation parent we check the fence keys and see if those are as expected.
We need to ensure that the copy is consistent with the data and not unlatched.
This gives us a similar message count as for the B-link tree as we did not need to validate the parent for splits
The difference is that we can then not exploit the neighbor node but need to restart.

#+BEGIN_SRC
Read_version, Read_node & Read_version while processing 
#+END_SRC
  
** Two-sided
vary easy as this is the normal modus operandi

** Mixed

Here the inner nodes are traversed via two-sided RPCs
This means that we get the inner node back which points to some remote leaf
This is fetched via RDMA again

** Split is tricky

1. traverse inner
2. get remote pointer back and fetch leaf
3. xlock leaf check if leaf has space for the new key
4. split localy since those changes are not visible and reserve space
5. then RPC to check if parent has space for the new sep and pointers, must ensure that parent is the same? not really right? 
6. if the split is fine write back new splits
7. otherwise restart

** Interface

#+BEGIN_SRC
  BTree<Inner<1S>, Leaf<1S>> // one-sided
  BTree<Inner<2S>, Leaf<2S>> // two-sided client
  BTree<Inner<Local>, Leaf<Local>> // two-sided server
  BTree<Inner<2S>, Leaf<1S>> // Hybrid client
  BTree<Inner<Local>, Void> // Hybrid server
#+END_SRC

** Guards
They abstract the one-sided and local latching information.
They should behave very similar to each other and can be prototyped quite easily.

** Structure

- always use a metadata page which stores the root (even local)
- Same input for leaf lookup and insert (leaf ptr*)
- Same input for scans on leaf level (inner node&) to prefetch
- Implement correct sync. scheme which should be encapsulated with the one-sided guards
- Use fence keys for scan continuation and could be exploited for caching

** Steps
*** Wednesday 
- Local prototype with local functions and code spearation + guards and Multithreading.
- insert, lookup and scans
- run all consistency checks and logic checks 
- Implement one-sided guards memcpy? should basically work, right?

*** Thrusday & Friday  
- Prepare farm or NAM code? 
- write and test guards as those are very important
- test code with the skewed and uniform versions 

